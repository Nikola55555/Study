"""
1. поддерживают доступ по ключу, а не по индексу
2. неупорядоченные коллекции произвольных объектов
3. имеют переменную длину, разнородны и допускают произвольно глубокое вложение
4. относятся к категории  "изменяемое отображение"
5. представляют собой таблицы ссылок на объекты (хэш-таблицы)
"""

D = {}                                 # Пустой словарь
D = {'name':'Bob', 'age': 40}          # Двухэлементный словарь
E = {'cto':{'name':'Bob', 'age': 40}}  # Вложение
                                   # Альтернативные методики создания:
D = dict(name='Bob', age=40)           # ключевые слова
D = dict([('name', 'Bob'), ('age', 40)]) # Пары ключ/значение
D = dict(zip(keylist, valuelist))       # Упакованные пары ключ/значение
D = dict.fromkeys(['name', 'age'])      # Списки ключей
D['name']                               # индексирование по ключу
E['cto']['age']                         # индексирование по ключу
                                    # Членство:
'age' in D                              # проверка присутствия ключа

                                    # Методы:
D.keys()                                # Все ключи
D.values()                              # Все значения
D.items()                               # Все кортежи ключ + значение
D.copy()                                # Копирование (верхнего уровня)
D.clear()                               # Очистка (удаление всех элементов)
D.update(D2)                            # объединение по ключам
D.get(key, default?)                    # Извлечение по ключу; если отсутствует, тогда вернуть стандартное значение (или None)
D.pop(key, default?)                    # Удаление по ключу; если отсутствует, тогда вернуть стандартное значение (или ощибку)
D.setdefault(key, default?)             # Установка по ключу; если отсутствует, тогда установить в стандартное значение или None
D.popitem()                             # Удаление/возвращение любой пары (ключ, значение)

len(D)                                  # Длина: количество сохраненных элементов
D[key] = 42                             # Добавление ключей; изменение значений, связанных с ключами
del D(key)                              # Удаление элемента по ключу
list(D.keys())                          # Словарные представления

D1.keys() & D2.keys()                   # Словарные представления
D = {x: x*2 for x in range(10)}         # Включение словаря

D = {'spam': 2, 'ham': 1, 'eggs': 3}    # Создание словаря
D['spam']                               # Извлечение значения по ключу

D['ham'] = ['grill', 'bake', 'fry']     #
print(D)        #  {'spam': 2, 'ham': ['grill', 'bake', 'fry'], 'eggs': 3}
del D['eggs']   # Удаление элемента
D['branch'] = 'bacon' # Добавление нового элемента
D     # {'spam': 2, 'ham': 1, 'eggs': 3, 'branch': 'bacon'}

del D['branch']
D    # {'spam': 2, 'ham': 1, 'eggs': 3}
list(D.values())    # [2, 1, 3]
list(D.items())     # [('spam', 2), ('ham', 1), ('eggs', 3)]

table = {'1975': 'Holy Grail', '1979': 'Life jf Brian', '1983': 'The Meaning of Life'}
year = '1983'
movie = table[year]  # 'The Meaning of Life'

for year in table:   # To же, что и for year in table, keys()
    print(year + '\t' + table[year])    # 1979 Life of Brian
                                        # 1975 Holy Grail
                                        # 1983 The Meaning of Life

dict.fromkeys ([ 'а', 'Ь'], 0)  # Один из способов создания словаря из упакованных ключей при условии, что значения будут одинаковы

D = {x: x**2 for x in [1, 2, 3, 4]}    # {1: 1, 2: 4, 3: 9, 4: 16} Словарное включение

D = dict.fromkeys('SPAM')    #

D = dict(a=1, b=2, c=3)
Ks = D.keys()
Ks.sort()   # Сортировка объекта представления не работает

Ks = list(Ks)  # Преобразуем в список
Ks.sort()      # и тогда сортируем
for k in Ks: print(k, D[k])  # Печатаем

a 1
b 2
c 3

Ks = D.keys()  #  Или можно вызвать sorted на ключах
for k in sorted(Ks): print(k, D[k]) # sorted принимает любой итерируемый объект